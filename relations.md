Связи
=====

- [Связи к обектам](#К-объектам-Один-к-одному-или-Многие-к-одному)
- [Связи к коллекциям](#К-коллекциям-Один-ко-многим-или-Многие-ко-многим)


К объектам: Один к одному или Многие к одному
---------------------------------------------

Обявить массив `$objects` связанных объектов.
Каждый элемент - это key-value пара, у которой
- `key` - имя свойства, через которое обращаться к связанному объекту
- `value` - массив со следующими определениями:
  - Класс связанного обекта
  - просто null :) (тут будет храниться сам объект после его загрузки)
  - Имя поля (внешнего ключа) в БД, по которому устанавливается связь ()

### один к одному

Например, у пользователя есть профиль - отдельная таблица в которую вынесены
все редко использующиеся данные и дополнительные сведения.
Одной записи из таблицы пользователей соответствует одна из таблицы профилей.
У этих записей одинаковые `id` и, кроме того, что они(id) являются первичными ключами,
они(id) ещё являются вторичными ключами и ссылаются друг на друга. Ммм... тогда их удалить
будет сложновато... :) Ну пусть FK будет проставлен только в таблице профилей,
но мы в голове держим, что в таблице пользователей поле `id` тоже можно рассматривать как
FK на таблицу профилей.

```php
	/**
	 * @property Profile $profile профиль пользователя
	 */
	class User extends Object
	{
		// ...
		
		protected $objects = array(
			'profile' => array('Profile', null, 'id')
		);
	}
	/**
	 * @property CUser $user пользователь этого профиля
	 */
	class Profile extends Object
	{
		// ...
		
		protected $objects = array(
			'user' => array('User', null, 'id')
		);
	}
```	

### многие к одному

Например, у поста есть поле `user_id`, которое ссылается на пользователя,
написавшего пост:

```php
	/**
	 * @property CUser $user пользователь, который написал этот пост
	 */
	class Post extends Object
	{
		// ...
		
		protected $objects = array(
			'user' => array('User', null, 'user_id')
		);
	}
```



К коллекциям: Один ко многим или Многие ко многим
-------------------------------------------------

Обявить массив `$collections` связанных коллекций.

Каждый элемент - это key-value пара, у которой
- `key` - имя свойства, через которое обращаться к связанной коллекции
- `value` - массив со следующими определениями:
  - Класс связанной коллекции
  - просто null :) (тут будет храниться сама коллекция после её загрузки)

### один ко многим

Например, у пользователя есть набор(коллекция) постов, которые он написал.
В этом случае нужно использовать коллекцию `ObjectSingleCollection` с
[предопределённой фильтрацией по внешнему ключу](collection.md#Один-ко-многим).

```php
	/**
	 * @property UserPostsCollection $posts
	 */
	class User extends Object
	{
		protected $collections = array(
			'posts' => array('UserPostsCollection', null),
		);
	}
```

### многие ко многим

И другой пример, но реадизуется также. У пользователя может быть несколько ролей.
В этом случае используем коллекцию `ObjectMultiCollection` с
[предопределённой фильтрацией по связующей таблице многие ко многим](collection.md#Многие-ко-многим)
По сути ничем не отличается, только ссылается на другого типа коллекцию.

```php
	/**
	 * @property UserRolesCollection $roles
	 */
	class User extends Object
	{
		protected $collections = array(
			'roles' => array('UserRolesCollection', null),
		);
	}
```
